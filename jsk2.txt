Breadth first serch
g={'A':['B','C'],'B':['D','E'],'C':['F'],'D':[],'E':[],'F':[]}
q=['A'];v=[]
while q:
  n=q.pop(0)
  if n not in v:
    print(n,end=' ')
    v.append(n)
    q+=g[n]

DFS 
g={'A':['B','C'],'B':['D','E'],'C':['F'],'D':[],'E':[],'F':[]}
v=set()
def dfs(n):
  if n not in v:
    print(n,end=' ')
    v.add(n)
    for x in g[n]: dfs(x)
dfs('A')


Prolog
Code:
 %Facts
 weather(cold).
 weather(rainy).
 %Rules
 wear(jacket) :- weather(cold).
 wear(raincoat) :- weather(rainy).
 %Multiple suggestions
 what_to_wear(Item) :- wear(Item).
 Query:
 ?- what_to_wear(Item).


  Code:
 %Facts
 student(alice, 85).
 student(bob, 45).
 student(charlie, 60).
 %Rule: pass if marks >= 50
 eligible(Name) :- student(Name, Marks), Marks >= 50.
 Query:
 ?- eligible(Name).



 A*Algohritm

 import heapq

# Goal state
goal = [[1,2,3],
        [4,5,6],
        [7,8,0]]  # 0 = blank

# Manhattan distance heuristic
def h(state):
    dist = 0
    for i in range(3):
        for j in range(3):
            val = state[i][j]
            if val != 0:
                x, y = divmod(val-1, 3)
                dist += abs(x - i) + abs(y - j)
    return dist

# Convert nested list to tuple (for hashing)
def to_tuple(state):
    return tuple(tuple(r) for r in state)

# Find blank (0) position
def find_zero(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

# Generate next states
def neighbors(state):
    x, y = find_zero(state)
    moves = [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]
    result = []
    for nx, ny in moves:
        if 0 <= nx < 3 and 0 <= ny < 3:
            new = [row[:] for row in state]
            new[x][y], new[nx][ny] = new[nx][ny], new[x][y]
            result.append(new)
    return result

def a_star(start):
    pq = []
    heapq.heappush(pq, (h(start), 0, start, []))  # (f = g+h, g, state, path)
    visited = set()

    while pq:
        f, g, state, path = heapq.heappop(pq)
        if to_tuple(state) in visited:
            continue
        visited.add(to_tuple(state))

        if state == goal:
            return path + [state]

        for nxt in neighbors(state):
            heapq.heappush(pq, (g + 1 + h(nxt), g + 1, nxt, path + [state]))
    return None

# Example start state
start = [[1,2,3],
         [4,0,6],
         [7,5,8]]

solution = a_star(start)

if solution:
    for s in solution:
        for row in s: print(row)
        print()
else:
    print("No solution found.")


MIN-MAX Algohritm

import math

# Initialize board
board = [' ']*9  # 3x3 grid as a list
player, ai = 'X', 'O'

# Display the board
def show(b):
    print(f"{b[0]}|{b[1]}|{b[2]}\n-+-+-\n{b[3]}|{b[4]}|{b[5]}\n-+-+-\n{b[6]}|{b[7]}|{b[8]}\n")

# Check winner
def win(b, s):
    combos = [(0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6)]
    return any(b[x]==b[y]==b[z]==s for x,y,z in combos)

# Minimax function
def minimax(b, depth, is_max):
    if win(b, ai): return 10 - depth
    if win(b, player): return depth - 10
    if ' ' not in b: return 0

    if is_max:
        best = -math.inf
        for i in range(9):
            if b[i]==' ':
                b[i]=ai
                best = max(best, minimax(b, depth+1, False))
                b[i]=' '
        return best
    else:
        best = math.inf
        for i in range(9):
            if b[i]==' ':
                b[i]=player
                best = min(best, minimax(b, depth+1, True))
                b[i]=' '
        return best

# Best move for AI
def best_move():
    best_val = -math.inf
    move = -1
    for i in range(9):
        if board[i]==' ':
            board[i]=ai
            val = minimax(board, 0, False)
            board[i]=' '
            if val > best_val:
                best_val, move = val, i
    return move

# Game loop
while True:
    show(board)
    if ' ' not in board or win(board, ai) or win(board, player):
        break
    move = int(input("Enter your move (0-8): "))
    if board[move] == ' ':
        board[move] = player
        if not win(board, player) and ' ' in board:
            board[best_move()] = ai

show(board)
if win(board, player): print("You win!")
elif win(board, ai): print("AI wins!")
else: print("Draw!")



Implementation of Hill Climbing optimization algorithm on a non-linear

import math, random

# Non-linear function (objective)
def f(x):
    return -(x**2 - 10*math.cos(2*math.pi*x) + 10)  # negative for maximization

# Hill Climbing
x = random.uniform(-5, 5)  # start randomly
step = 0.1
for i in range(1000):
    new_x = x + random.uniform(-step, step)
    if f(new_x) > f(x):   # accept better solution
        x = new_x

print("Best x:", round(x,4))
print("Best f(x):", round(f(x),4))
